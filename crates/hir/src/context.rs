use std::str::FromStr;

use la_arena::Idx;
use parser::SyntaxKind;
use text_size::TextRange;

use crate::interner::Interner;
use crate::scope::Scopes;
use crate::typecheck::TypeCheckResults;
use crate::{
    BinaryExpr, BinaryOp, BlockExpr, CallExpr, Database, Expr, FunctionExpr, IfExpr, LocalDef,
    LocalRef, LocalRefName, Type, UnaryExpr, UnaryOp,
};

/// Character appended to names/keys to indicate it was modified or generated by the compiler
const COMPILER_BRAND: char = '~';

// temp
pub type Diagnostic = ();

#[derive(Debug, Default)]
pub struct Context {
    /// Database holding the lowered expressions and associated data
    pub(crate) database: Database,

    /// Results of type checking and inferring expressions
    pub(crate) typecheck_results: TypeCheckResults,

    /// Diagnostics found while lowering
    pub(crate) diagnostics: Vec<Diagnostic>,

    pub(crate) scopes: Scopes,

    pub(crate) interner: Interner,
}

// Public functions
impl Context {
    /// Returns the expression at the given index
    pub fn expr(&self, idx: Idx<Expr>) -> &Expr {
        &self.database.exprs[idx]
    }

    // pub fn local_def(&self, idx: Idx<LetBinding>) -> &LetBinding {
    //     &self.database.let_bindings[idx]
    // }

    pub fn type_of_expr(&self, idx: Idx<Expr>) -> &Type {
        self.typecheck_results
            .get_expr_type(idx)
            .expect("type checking to be complete")
    }

    // pub fn type_of_local(&self, name: String) -> Option<&Type> {
    //     // self.scopes
    // }

    pub fn range_of(&self, idx: Idx<Expr>) -> TextRange {
        self.database.expr_ranges[idx]
    }
}

impl Context {
    pub(crate) fn alloc_expr(&mut self, expr: Expr, ast: Option<ast::Expr>) -> Idx<Expr> {
        self.database.alloc_expr(expr, ast)
    }

    // TODO: pattern, not name - possibly reworking the whole thing for pattern matching
    // ex.
    // `let [a, b] = some_func ()`
    // do we desugar first to:
    // ```
    // let temp = some_func ()
    // let a = temp.0    // give 'a' the stack slot of temp.0 directly?
    // let b = temp.1    // give 'b' the stack slot of temp.1 directly?
    // ```
    // pub(crate) fn add_let_binding(
    //     &mut self,
    //     name: String,
    //     let_binding: LetBinding,
    // ) -> Idx<LetBinding> {
    //     // let idx = self.database.alloc_let_binding(let_binding);

    //     // self.scopes.insert_local_binding(name, idx);

    //     idx
    // }

    // pub(crate) fn lookup_name(&self, name: &str) -> Option<Idx<LetBinding>> {
    //     self.scopes
    //         .into_iter()
    //         .find_map(|scope| scope.get_local(name))
    // }

    pub(crate) fn push_scope(&mut self) {
        self.scopes.push();
    }

    pub(crate) fn pop_scope(&mut self) {
        self.scopes.pop();
    }
}

// Lowering functions
impl Context {
    pub(crate) fn lower_expr(&mut self, ast: Option<ast::Expr>) -> Idx<Expr> {
        use ast::Expr::*;
        let expr = if let Some(ast) = ast.clone() {
            match ast {
                Binary(ast) => self.lower_binary(ast),
                Block(ast) => self.lower_block(ast),
                BoolLiteral(ast) => self.lower_bool_literal(ast),
                Call(ast) => self.lower_call(ast),
                FloatLiteral(ast) => self.lower_float_literal(ast),
                Function(ast) => self.lower_function_expr(ast),
                Ident(ast) => self.lower_ident(ast),
                If(ast) => self.lower_if_expr(ast),
                IntLiteral(ast) => self.lower_int_literal(ast),
                LetBinding(ast) => self.lower_let_binding(ast),
                Loop(ast) => self.lower_loop(ast),
                Paren(ast) => return self.lower_expr(ast.expr()),
                StringLiteral(ast) => self.lower_string_literal(ast),
                TypeExpr(ast) => self.lower_type_expr(ast),
                Unary(ast) => self.lower_unary(ast),
            }
        } else {
            Expr::Empty
        };

        self.alloc_expr(expr, ast)
    }

    fn lower_let_binding(&mut self, ast: ast::LetBinding) -> Expr {
        // TODO: desugar patterns into separate LocalDef
        let mut name = ast.name().unwrap().text().to_string();
        name.push(COMPILER_BRAND);
        let name = self.interner.intern(&name);

        let key = self.scopes.insert_local_def(name);

        let value = self.lower_expr(ast.value());

        // TODO: lower type_annotation from ast
        let type_annotation = None;

        Expr::LocalDef(LocalDef {
            key,
            value,
            type_annotation,
        })
    }

    fn lower_type_expr(&mut self, ast: ast::TypeExpr) -> Expr {
        todo!()
    }

    fn lower_bool_literal(&mut self, ast: ast::BoolLiteral) -> Expr {
        let value: Option<bool> = ast.value().and_then(|token| token.text().parse().ok());

        value.map_or(Expr::Empty, Expr::BoolLiteral)
    }

    fn lower_float_literal(&mut self, ast: ast::FloatLiteral) -> Expr {
        let value: Option<f64> = ast
            .value()
            .and_then(|token| parse_ignore_underscore(token.text()));

        value.map_or(Expr::Empty, Expr::FloatLiteral)
    }

    fn lower_int_literal(&mut self, ast: ast::IntLiteral) -> Expr {
        let value: Option<i32> = ast
            .value()
            .and_then(|token| parse_ignore_underscore(token.text()));

        value.map_or(Expr::Empty, Expr::IntLiteral)
    }

    fn lower_string_literal(&mut self, ast: ast::StringLiteral) -> Expr {
        let value: Option<String> = ast.value().map(|token| token.text().to_owned());

        // TODO: extract trimming to a separate function and use value.map_or
        if let Some(s) = value {
            let s = &s[1..s.len() - 1]; // remove leading and trailing quotes

            // TODO: intern the string here
            Expr::StringLiteral(s.to_string())
        } else {
            Expr::Empty
        }
    }

    fn lower_binary(&mut self, ast: ast::Binary) -> Expr {
        let op = match ast.op().expect("valid binary op token").kind() {
            SyntaxKind::Plus => BinaryOp::Add,
            SyntaxKind::Dash => BinaryOp::Sub,
            SyntaxKind::Star => BinaryOp::Mul,
            SyntaxKind::Slash => BinaryOp::Div,
            SyntaxKind::Dot => BinaryOp::Path,
            SyntaxKind::Caret => BinaryOp::Exp,
            SyntaxKind::Percent => BinaryOp::Rem,
            _ => unreachable!(),
        };

        let lhs = self.lower_expr(ast.lhs());
        let rhs = self.lower_expr(ast.rhs());

        Expr::Binary(BinaryExpr { op, lhs, rhs })
    }

    fn lower_unary(&mut self, ast: ast::Unary) -> Expr {
        let op = match ast.op().unwrap().kind() {
            SyntaxKind::Dash => UnaryOp::Neg,
            SyntaxKind::Not => UnaryOp::Not,
            _ => unreachable!(),
        };

        let expr = self.lower_expr(ast.expr());

        Expr::Unary(UnaryExpr { op, expr })
    }

    fn lower_block(&mut self, ast: ast::Block) -> Expr {
        self.push_scope();

        let exprs = ast
            .exprs()
            .map(|expr_ast| self.lower_expr(Some(expr_ast)))
            .collect();

        self.pop_scope();

        Expr::Block(BlockExpr { exprs })
    }

    fn lower_loop(&mut self, ast: ast::LoopExpr) -> Expr {
        dbg!(&ast);

        self.push_scope();
        // identify break expressions
        // lower statements/expressions
        self.pop_scope();

        // break value?
        todo!()
    }

    // TODO: rather than Ident, Local? Call? local_or_call?
    fn lower_ident(&mut self, ast: ast::Ident) -> Expr {
        // if ast::Call doesn't have ast::Path, return Empty
        // if ast::Path doesn't have top-level-name, return Empty

        // if it has a nested name (?)  (it uses "module.function" for paths, like "io.write")
        // // Make a FullyQualifiedName (FQN) with module name + function name
        // // Look up function in world index
        // // OK (return lower_call) => update context state with other module reference, update symbol map, lower call
        // // Err (return Expr::Empty) => update symbol map, add diagnostic

        // if it is in current scope (as a non-function variable - DIFFERENT THAN MINE)
        // // check if it's trying to call a non-function as a function, add diagnostic
        // // update symbol map
        // // (return Expr::Local)

        // if it is a param of the current function
        // // update symbol map
        // // (return Expr::Param)

        // if it is a "definition" (a function or record)
        // // update symbol map
        // // (return lower_call)

        panic!("which tests are running this function?");

        // Expr::LocalRef(LocalRef {
        //     name: ast.name_token().unwrap().text().into(),
        //     local_idx: Some(0),
        // })
    }

    fn lower_call(&mut self, ast: ast::Call) -> Expr {
        let path = ast.path().unwrap();
        let mut idents = path.ident_strings();

        // TODO: handle multiple idents in a Path
        let name = idents.next().unwrap();
        let call_args = ast.args();

        if let Some(call_args) = call_args {
            let args = call_args
                .args()
                .map(|expr| self.lower_expr(Some(expr)))
                .collect();

            // TODO: check for mismatched arg count?
            Expr::Call(CallExpr { path: name, args })
        } else {
            self.lower_name_ref(name)
        }
    }

    fn lower_name_ref(&mut self, name: String) -> Expr {
        let mut name = name;
        name.push(COMPILER_BRAND);

        let name = self.interner.intern(&name);
        let local_key = self.scopes.find_local(name);

        let local_ref = if let Some(local_key) = local_key {
            LocalRef {
                name: LocalRefName::Resolved(local_key),
            }
        } else {
            LocalRef {
                name: LocalRefName::Unresolved(name),
            }
        };

        Expr::LocalRef(local_ref)
    }

    fn lower_function_expr(&mut self, ast: ast::Function) -> Expr {
        let params = todo!();
        let return_type_annotation = todo!();

        self.push_scope();
        let body = todo!(); // or call lower_block?
        self.pop_scope();

        Expr::Function(FunctionExpr {
            params,
            body,
            return_type_annotation,
        })
    }

    fn lower_if_expr(&mut self, ast: ast::IfExpr) -> Expr {
        let condition = self.lower_expr(ast.condition_expr());

        // TODO: worth making a function/macro i.e. `with_scope` to reduce clutter?
        self.push_scope();
        let then_branch = self.lower_expr(ast.then_branch());
        self.pop_scope();

        // TODO: push/pop scope only if there is an else_branch
        self.push_scope();
        let else_branch = ast
            .else_branch()
            .map(|else_branch| self.lower_expr(Some(else_branch)));
        self.pop_scope();

        Expr::If(IfExpr {
            condition,
            then_branch,
            else_branch,
        })
    }
}

fn parse_ignore_underscore<T: FromStr>(s: &str) -> Option<T> {
    let mut s = s.to_string();
    s.retain(|c| c != '_');

    s.parse().ok()
}
