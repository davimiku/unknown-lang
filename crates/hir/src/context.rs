use std::str::FromStr;

use la_arena::Idx;
use parser::SyntaxKind;
use text_size::TextRange;

use crate::expr::{
    BinaryExpr, CallExpr, FunctionExpr, FunctionParam, IfExpr, LocalDefExpr, LocalRefExpr,
    LocalRefName, UnaryExpr,
};
use crate::interner::{Interner, Key};
use crate::scope::Scopes;
use crate::type_expr::TypeExpr;
use crate::typecheck::TypeCheckResults;
use crate::{BinaryOp, BlockExpr, Database, Expr, Type, UnaryOp};

/// Character appended to names/keys to indicate it was modified or generated by the compiler
pub const COMPILER_BRAND: char = '~';

// temp
pub type Diagnostic = ();

#[derive(Debug, Default)]
pub struct Context {
    /// Database holding the lowered expressions and associated data
    pub(crate) database: Database,

    /// Results of type checking and inferring expressions
    pub(crate) typecheck_results: TypeCheckResults,

    /// Diagnostics found while lowering
    pub(crate) diagnostics: Vec<Diagnostic>,

    pub(crate) scopes: Scopes,

    pub(crate) interner: Interner,
}

// Public functions
impl Context {
    /// Returns the expression at the given index
    pub fn expr(&self, idx: Idx<Expr>) -> &Expr {
        &self.database.exprs[idx]
    }

    /// Returns the type expression at the given index
    pub fn type_expr(&self, idx: Idx<TypeExpr>) -> &TypeExpr {
        &self.database.type_exprs[idx]
    }

    pub fn lookup(&self, key: Key) -> &str {
        self.interner.lookup(key)
    }

    pub fn type_of_expr(&self, idx: Idx<Expr>) -> &Type {
        self.typecheck_results
            .get_expr_type(idx)
            .expect("type checking to be complete")
    }

    pub fn range_of(&self, idx: Idx<Expr>) -> TextRange {
        self.database.expr_ranges[idx]
    }
}

impl Context {
    pub(crate) fn alloc_expr(&mut self, expr: Expr, ast: Option<ast::Expr>) -> Idx<Expr> {
        self.database.alloc_expr(expr, ast)
    }

    // TODO: pattern, not name - possibly reworking the whole thing for pattern matching
    // ex.
    // `let [a, b] = some_func ()`
    // do we desugar first to:
    // ```
    // let temp = some_func ()
    // let a = temp.0    // give 'a' the stack slot of temp.0 directly?
    // let b = temp.1    // give 'b' the stack slot of temp.1 directly?
    // ```
    // pub(crate) fn add_let_binding(
    //     &mut self,
    //     name: String,
    //     let_binding: LetBinding,
    // ) -> Idx<LetBinding> {
    //     // let idx = self.database.alloc_let_binding(let_binding);

    //     // self.scopes.insert_local_binding(name, idx);

    //     idx
    // }

    // pub(crate) fn lookup_name(&self, name: &str) -> Option<Idx<LetBinding>> {
    //     self.scopes
    //         .into_iter()
    //         .find_map(|scope| scope.get_local(name))
    // }

    pub(crate) fn push_scope(&mut self) {
        self.scopes.push();
    }

    pub(crate) fn pop_scope(&mut self) {
        self.scopes.pop();
    }
}

// Lowering functions
impl Context {
    pub(crate) fn lower_expr(&mut self, ast: Option<ast::Expr>) -> Idx<Expr> {
        use ast::Expr::*;
        let expr = if let Some(ast) = ast.clone() {
            match ast {
                Binary(ast) => self.lower_binary(ast),
                Block(ast) => self.lower_block(ast),
                BoolLiteral(ast) => self.lower_bool_literal(ast),
                Call(ast) => self.lower_call(ast),
                FloatLiteral(ast) => self.lower_float_literal(ast),
                Function(ast) => self.lower_function_expr(ast),
                Ident(ast) => self.lower_ident(ast),
                If(ast) => self.lower_if_expr(ast),
                IntLiteral(ast) => self.lower_int_literal(ast),
                LetBinding(ast) => self.lower_let_binding(ast),
                Loop(ast) => self.lower_loop(ast),
                Paren(ast) => return self.lower_expr(ast.expr()),
                StringLiteral(ast) => self.lower_string_literal(ast),
                Unary(ast) => self.lower_unary(ast),
            }
        } else {
            Expr::Empty
        };

        self.alloc_expr(expr, ast)
    }

    fn lower_let_binding(&mut self, ast: ast::LetBinding) -> Expr {
        // TODO: desugar patterns into separate LocalDef
        let mut name = ast.name().unwrap().text().to_string();
        name.push(COMPILER_BRAND);
        let name = self.interner.intern(&name);

        let key = self.scopes.insert_local_def(name);

        let value = self.lower_expr(ast.value());

        // TODO: lower type_annotation from ast
        let type_annotation = None;

        Expr::LocalDef(LocalDefExpr {
            key,
            value,
            type_annotation,
        })
    }

    fn lower_type_expr(&mut self, ast: ast::TypeExpr) -> TypeExpr {
        TypeExpr::Empty
    }

    fn lower_bool_literal(&mut self, ast: ast::BoolLiteral) -> Expr {
        let value: Option<bool> = ast.value().and_then(|token| token.text().parse().ok());

        value.map_or(Expr::Empty, Expr::BoolLiteral)
    }

    fn lower_float_literal(&mut self, ast: ast::FloatLiteral) -> Expr {
        let value: Option<f64> = ast
            .value()
            .and_then(|token| parse_ignore_underscore(token.text()));

        value.map_or(Expr::Empty, Expr::FloatLiteral)
    }

    fn lower_int_literal(&mut self, ast: ast::IntLiteral) -> Expr {
        let value: Option<i32> = ast
            .value()
            .and_then(|token| parse_ignore_underscore(token.text()));

        value.map_or(Expr::Empty, Expr::IntLiteral)
    }

    fn lower_string_literal(&mut self, ast: ast::StringLiteral) -> Expr {
        let value: Option<String> = ast.value().map(|token| token.text().to_owned());

        // TODO: extract trimming to a separate function and use value.map_or
        if let Some(s) = value {
            let s = &s[1..s.len() - 1]; // remove leading and trailing quotes

            let key = self.interner.intern(s);
            Expr::StringLiteral(key)
        } else {
            Expr::Empty
        }
    }

    fn lower_binary(&mut self, ast: ast::Binary) -> Expr {
        let op = match ast.op().expect("valid binary op token").kind() {
            SyntaxKind::Plus => BinaryOp::Add,
            SyntaxKind::Dash => BinaryOp::Sub,
            SyntaxKind::Star => BinaryOp::Mul,
            SyntaxKind::Slash => BinaryOp::Div,
            SyntaxKind::PlusPlus => BinaryOp::Concat,
            SyntaxKind::Dot => BinaryOp::Path,
            SyntaxKind::Caret => BinaryOp::Exp,
            SyntaxKind::Percent => BinaryOp::Rem,
            _ => unreachable!(),
        };

        let lhs = self.lower_expr(ast.lhs());
        let rhs = self.lower_expr(ast.rhs());

        Expr::Binary(BinaryExpr { op, lhs, rhs })
    }

    fn lower_unary(&mut self, ast: ast::Unary) -> Expr {
        let op = match ast.op().unwrap().kind() {
            SyntaxKind::Dash => UnaryOp::Neg,
            SyntaxKind::Bang => UnaryOp::Not,
            _ => unreachable!(),
        };

        let expr = self.lower_expr(ast.expr());

        Expr::Unary(UnaryExpr { op, expr })
    }

    fn lower_block(&mut self, ast: ast::Block) -> Expr {
        self.push_scope();

        let exprs = ast
            .exprs()
            .map(|expr_ast| self.lower_expr(Some(expr_ast)))
            .collect();

        self.pop_scope();

        Expr::Block(BlockExpr { exprs })
    }

    fn lower_loop(&mut self, ast: ast::Loop) -> Expr {
        self.push_scope();
        // identify break expressions
        // lower statements/expressions
        self.pop_scope();

        // break value?
        todo!()
    }

    // TODO: rather than Ident, Local? Call? local_or_call?
    fn lower_ident(&mut self, ast: ast::Ident) -> Expr {
        // if ast::Call doesn't have ast::Path, return Empty
        // if ast::Path doesn't have top-level-name, return Empty

        // if it has a nested name (?)  (it uses "module.function" for paths, like "io.write")
        // // Make a FullyQualifiedName (FQN) with module name + function name
        // // Look up function in world index
        // // OK (return lower_call) => update context state with other module reference, update symbol map, lower call
        // // Err (return Expr::Empty) => update symbol map, add diagnostic

        // if it is in current scope (as a non-function variable - DIFFERENT THAN MINE)
        // // check if it's trying to call a non-function as a function, add diagnostic
        // // update symbol map
        // // (return Expr::Local)

        // if it is a param of the current function
        // // update symbol map
        // // (return Expr::Param)

        // if it is a "definition" (a function or record)
        // // update symbol map
        // // (return lower_call)

        panic!("which tests are running this function?");

        // Expr::LocalRef(LocalRef {
        //     name: ast.name_token().unwrap().text().into(),
        //     local_idx: Some(0),
        // })
    }

    fn lower_call(&mut self, ast: ast::Call) -> Expr {
        let path = ast.path().unwrap();
        let mut idents = path.ident_strings();

        // TODO: handle multiple idents in a Path
        let name = idents.next().unwrap();
        let call_args = ast.args();

        if let Some(call_args) = call_args {
            let args = call_args
                .args()
                .map(|expr| self.lower_expr(Some(expr)))
                .collect();

            // TODO: check for mismatched arg count?
            Expr::Call(CallExpr { path: name, args })
        } else {
            self.lower_name_ref(name)
        }
    }

    fn lower_name_ref(&mut self, name: String) -> Expr {
        let mut name = name;
        name.push(COMPILER_BRAND);

        let name = self.interner.intern(&name);
        let local_key = self.scopes.find_local(name);

        let local_ref = if let Some(local_key) = local_key {
            LocalRefExpr {
                name: LocalRefName::Resolved(local_key),
            }
        } else {
            LocalRefExpr {
                name: LocalRefName::Unresolved(name),
            }
        };

        Expr::LocalRef(local_ref)
    }

    fn lower_function_expr(&mut self, function_ast: ast::Function) -> Expr {
        let params = function_ast
            .param_list()
            .params()
            .map(|param| {
                let ident = param.ident().expect("function parameter to have ident");
                let mut name = ident.name().unwrap();
                name.push(COMPILER_BRAND);

                let key = self.interner.intern(&name);
                let key = self.scopes.insert_local_def(key);

                FunctionParam {
                    name: key,
                    ty: None,
                }
            })
            .collect();

        let body = function_ast.body().map(|body| {
            self.push_scope();
            let lowered = self.lower_expr(Some(body));
            self.pop_scope();
            lowered
        });
        let body = body.expect("TODO: handle missing function body");

        Expr::Function(FunctionExpr { params, body })
    }

    fn lower_if_expr(&mut self, ast: ast::If) -> Expr {
        let condition = self.lower_expr(ast.condition_expr());

        self.push_scope();
        let then_branch = self.lower_expr(ast.then_branch());
        self.pop_scope();

        let else_branch = ast.else_branch().map(|else_branch| {
            self.push_scope();
            let lowered = self.lower_expr(Some(else_branch));
            self.pop_scope();
            lowered
        });

        Expr::If(IfExpr {
            condition,
            then_branch,
            else_branch,
        })
    }
}

fn parse_ignore_underscore<T: FromStr>(s: &str) -> Option<T> {
    let mut s = s.to_string();
    s.retain(|c| c != '_');

    s.parse().ok()
}
